---
# 1) Install Docker on docker_nodes using your existing playbook (TOP-LEVEL)
- import_playbook: ../../../docker/playbooks/install_docker.yml

# 2) Online deploy (clone repo -> compose up) + Nginx/Certbot
- name: ONLINE Docker deploy (clone repo -> compose up) + HTTPS via Nginx/Certbot
  hosts: docker_nodes
  become: true

  vars:
    repo_url: "https://github.com/it2022031/DevOps-2025.git"
    project_dir: /opt/DevOps-2025
    compose_dir: "{{ project_dir }}/ansible/docker"

    # ONLINE public URL (βάλε FQDN όταν το έχεις, προς το παρόν IP)
    public_url: "http://34.170.9.226"

    # Certbot (θα δουλέψει όταν έχεις DNS σωστό + 80/443 open)
    public_fqdn: "ds2025.example.com"
    letsencrypt_email: "you@example.com"
    nginx_site: "ds2025-online"

  tasks:
    - name: Install prerequisites
      apt:
        name: [git, curl, ca-certificates]
        state: present
        update_cache: yes

    - name: Clone/update DevOps-2025 repo
      git:
        repo: "{{ repo_url }}"
        dest: "{{ project_dir }}"
        version: main
        force: yes

    - name: Ensure docker-compose.yml exists in repo
      stat:
        path: "{{ compose_dir }}/docker-compose.yml"
      register: dc

    - name: Fail if docker-compose.yml missing
      fail:
        msg: "Missing docker-compose.yml at {{ compose_dir }}/docker-compose.yml"
      when: not dc.stat.exists

    # IMPORTANT: compose has hardcoded 127.0.0.1:8081, so patch it for ONLINE
    - name: Patch docker-compose.yml (APP_PUBLIC_BASE_URL / APP_FRONTEND_URL) for ONLINE
      shell: |
        set -e
        cd "{{ compose_dir }}"
        sed -i 's|APP_PUBLIC_BASE_URL: "http://127.0.0.1:8081"|APP_PUBLIC_BASE_URL: "{{ public_url }}"|g' docker-compose.yml
        sed -i 's|APP_FRONTEND_URL: "http://127.0.0.1:8081"|APP_FRONTEND_URL: "{{ public_url }}"|g' docker-compose.yml
        grep -n 'APP_PUBLIC_BASE_URL\|APP_FRONTEND_URL' docker-compose.yml
      args:
        executable: /bin/bash
      changed_when: true

    - name: Compose up (force recreate so env changes apply)
      shell: |
        set -e
        cd "{{ compose_dir }}"
        (docker compose up -d --force-recreate || docker-compose up -d --force-recreate)
      args:
        executable: /bin/bash
      changed_when: true

    - name: Show backend env from container (debug)
      shell: |
        set -e
        docker exec docker-backend-1 printenv | egrep 'APP_PUBLIC_BASE_URL|APP_FRONTEND_URL' || true
      changed_when: false

    # --- Nginx + Certbot (HTTPS) ---
    - name: Install nginx + certbot
      apt:
        name: [nginx, certbot, python3-certbot-nginx]
        state: present
        update_cache: yes

    - name: Create webroot for certbot
      file:
        path: /var/www/certbot
        state: directory
        mode: "0755"

    - name: Write nginx vhost (HTTP)
      template:
        src: ../../nginx/templates/ds2025_docker.conf.j2
        dest: "/etc/nginx/sites-available/{{ nginx_site }}"
        mode: "0644"

    - name: Enable nginx site
      file:
        src: "/etc/nginx/sites-available/{{ nginx_site }}"
        dest: "/etc/nginx/sites-enabled/{{ nginx_site }}"
        state: link

    - name: Disable default site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent

    - name: Validate nginx config
      command: nginx -t
      changed_when: false

    - name: Restart nginx
      service:
        name: nginx
        state: restarted
        enabled: yes

    - name: Try obtain/renew LetsEncrypt cert (won't fail if domain not ready)
      command: >
        certbot --nginx -n
        --agree-tos
        -m {{ letsencrypt_email }}
        -d {{ public_fqdn }}
      register: certbot_out
      changed_when: "'Congratulations' in certbot_out.stdout or 'renewed' in certbot_out.stdout"
      failed_when: false

    - name: Show certbot output (info)
      debug:
        var: certbot_out.stdout_lines
